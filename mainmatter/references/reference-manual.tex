\title{The PicoLisp Reference}
\input{mainmatter/authors/alex}
\maketitle

% \section{PicoLisp Reference}
% \label{sec:refm-picolisp-reference}

% (c) Software Lab. Alexander Burger (originally published \href{http://software-lab.de/doc/ref.html}{here}).


\begin{abstract}

This document describes the concepts, data types, and kernel functions
of the \href{http://software-lab.de/down.html}{PicoLisp} system.

This is \emph{not} a Lisp tutorial. For an introduction to Lisp, a
traditional Lisp book (like~\cite{lisp1}) is recommended. Note, however,
that there are significant differences between PicoLisp and Maclisp
(and even greater differences to Common Lisp).

Please take a look at the \emph{PicoLisp Tutorial} for an
explanation of some aspects of PicoLisp, and scan through the list of
\emph{Frequently Asked Questions (FAQ)}.

\end{abstract}  

 
\section{Introduction}
\label{sec:refm-introduction}


PicoLisp is the result of a language design study, trying to answer the
question ``What is a minimal but useful architecture for a virtual
machine?''. Because opinions differ about what is meant by ``minimal'' and
``useful'', there are many answers to that question, and people might
consider other solutions more ``minimal'' or more ``useful''. But from a
practical point of view, PicoLisp has proven to be a valuable answer to
that question.

First of all, PicoLisp is a virtual machine architecture, and then a
programming language. It was designed in a ``bottom up'' way, and ``bottom
up'' is also the most natural way to understand and to use it: \emph{Form Follows Function}.

PicoLisp has been used in several commercial and research programming
projects since 1988. Its internal structures are simple enough, allowing
an experienced programmer always to fully understand what's going on
under the hood, and its language features, efficiency and extensibility
make it suitable for almost any practical programming task.

In a nutshell, emphasis was put on four design objectives. The PicoLisp
system should be

\begin{description}

\item[Simple] The internal data structure should be as simple as
  possible. Only one single data structure is used to build all higher
  level constructs.

\item[Unlimited] There are no limits imposed upon the language due to
  limitations of the virtual machine architecture. That is, there is
  no upper bound in symbol name length, number digit counts, stack
  depth, or data structure and buffer sizes, except for the total
  memory size of the host machine.

\item[Dynamic] Behavinor should be as dynamic as possible (``run''-time
  vs. ``compile''-time). All decisions are delayed until runtime where
  possible. This involves matters like memory management, dynamic
  symbol binding, and late method binding.

\item[Practical] PicoLisp is not just a toy of theoretical value. It
  is in use since 1988 in actual application development, research and
  production.

\end{description}

\section{The PicoLisp Machine}
\label{sec:refm-the-picolisp-machine}


An important point in the PicoLisp philosophy is the knowledge about the
architecture and data structures of the internal machinery. The
high-level constructs of the programming language directly map to that
machinery, making the whole system both understandable and predictable.

This is similar to assembly language programming, where the programmer
has complete control over the machine.


 
\subsection{The Cell}
\label{sec:refm-the-cell}


The PicoLisp virtual machine is both simpler and more powerful than most
current (hardware) processors. At the lowest level, it is constructed
from a single data structure called ``cell'':


\begin{wideverbatim}
+-----+-----+
| CAR | CDR |
+-----+-----+
\end{wideverbatim}

A cell is a pair of machine words, which traditionally are called CAR
and CDR in the Lisp terminology. These words can represent either a
numeric value (scalar) or the address of another cell (pointer). All
higher level data structures are built out of cells.

The type information of higher level data is contained in the pointers
to these data. Assuming the implementation on a byte-addressed physical
machine, and a pointer size of typically 4 bytes, each cell has a size
of 8 bytes. Therefore, the pointer to a cell must point to an 8-byte
boundary, and its bit-representation will look like:


\begin{wideverbatim}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxx000
\end{wideverbatim}

(the `\texttt{x}' means ``don't care''). For the individual data types, the
pointer is adjusted to point to other parts of a cell, in effect setting
some of the lower three bits to non-zero values. These bits are then
used by the interpreter to determine the data type.

In any case, bit(0) - the least significant of these bits - is reserved
as a mark bit for garbage collection.

Initially, all cells in the memory are unused (free), and linked
together to form a ``free list''. To create higher level data types at
runtime, cells are taken from that free list, and returned by the
garbage collector when they are no longer needed. All memory management
is done via that free list; there are no additional buffers, string
spaces or special memory areas, with two exceptions:

\begin{itemize}
\item A certain fixed area of memory is set aside to contain the executable
   code and global variables of the interpreter itself, and
\item a standard push down stack for return addresses and temporary
   storage. Both are not directly accessible by the programmer).
\end{itemize}


 
\subsection{Data Types}
\label{sec:refm-data-types}


On the virtual machine level, PicoLisp supports

\begin{itemize}
\item three base data types: Numbers, Symbols and Cons Pairs (Lists),
\item the three scope variations of symbols: Internal, Transient and
   External, and
\item the special symbol \texttt{NIL}.
\end{itemize}

They are all built from the single cell data structure, and all runtime
data cannot consist of any other types than these three.

The following diagram shows the complete data type hierarchy, consisting
of the three base types and the symbol variations:


\begin{wideverbatim}
                  cell
                   |
          +--------+--------+
          |        |        |
       Number    Symbol    List
                   |
                   |
 +--------+--------+--------+
 |        |        |        |
NIL   Internal Transient External
\end{wideverbatim}


\subsubsection{Numbers}
\label{sec:refm-numbers}%
A number can represent a signed integral value of arbitrary size. The
CARs of one or more cells hold the number's ``digits'' (each in the
machine's word size), to store the number's binary representation.


\begin{wideverbatim}
   Number
   |
   V
+-----+-----+
| DIG |  |  |
+-----+--+--+
         |
         V
      +-----+-----+
      | DIG |  |  |
      +-----+--+--+
               |
               V
              ...
\end{wideverbatim}

The first cell holds the least significant digit. The least significant
bit of that digit represents the sign.

The pointer to a number points into the middle of the CAR, with an
offset of 2 from the cell's start address. Therefore, the bit pattern of
a number will be:


\begin{wideverbatim}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxx010
\end{wideverbatim}

Thus, a number is recognized by the interpreter when bit(1) is non-zero.


\subsubsection{Symbols}
\label{sec:refm-symbols}%
A symbol is more complex than a number. Each symbol has a value, and
optionally a name and an arbitrary number of properties. The CDR of a
symbol cell is also called VAL, and the CAR points to the symbol's tail.
As a minimum, a symbol consists of a single cell, and has no name or
properties:


\begin{wideverbatim}
      Symbol
      |
      V
+-----+-----+
|  /  | VAL |
+-----+-----+
\end{wideverbatim}

That is, the symbol's tail is empty (points to \texttt{NIL}, as indicated by
the  \texttt{/}  character).

The pointer to a symbol points to the CDR of the cell, with an offset of
4 from the cell's start address. Therefore, the bit pattern of a symbol
will be:


\begin{wideverbatim}
xxxxxxxxxxxxxxxxxxxxxxxxxxxxx100
\end{wideverbatim}

Thus, a symbol is recognized by the interpreter when bit(2) is non-zero.

A property is a key-value pair, represented as a cell in the symbol's
tail. This is called a ``property list''. The property list may be
terminated by a number representing the symbol's name. In the following
example, a symbol with the name \texttt{''abc''} has three properties: A KEY/VAL
cell, a cell with only a KEY, and another KEY/VAL cell.


\begin{wideverbatim}
      Symbol
      |
      V
+-----+-----+
|  |  | VAL |
+--+--+-----+
   | tail
   |
   V                                                      name
   +-----+-----+     +-----+-----+     +-----+-----+     +-----+-----+
   |  |  |  ---+---> | KEY |  ---+---> |  |  |  ---+---> |'cba'|  /  |
   +--+--+-----+     +-----+-----+     +--+--+-----+     +-----+-----+
      |                                   |
      V                                   V
      +-----+-----+                       +-----+-----+
      | VAL | KEY |                       | VAL | KEY |
      +-----+-----+                       +-----+-----+
\end{wideverbatim}

Each property in a symbol's tail is either a symbol (like the single KEY
above, then it represents the boolean value \texttt{T}), or a cell with the
property key in its CDR and the property value in its CAR. In both
cases, the key should be a symbol, because searches in the property list
are performed using pointer comparisons.

The name of a symbol is stored as a number at the end of the tail. It
contains the characters of the name in UTF--8 encoding, using between
one and three 8-bit-bytes per character. The first byte of the first
character is stored in the lowest 8 bits of the number.

All symbols have the above structure, but depending on scope and
accessibility there are actually four types of symbols: \texttt{NIL},
\emph{internal}, \emph{transient} and
\emph{external} symbols.


\paragraph{NIL}
\label{sec:refm-nil}%
\texttt{NIL} is a special symbol which exists exactly once in the whole system.
It is used

\begin{itemize}
\item as an end-of-list marker
\item to represent the empty list
\item to represent the boolean value ``false''
\item to represent the absolute minimum
\item to represent a string of length zero
\item to represent the value ``Not a Number''
\item as the root of all class hierarchies
\end{itemize}

For that, \texttt{NIL} has a special structure:


\begin{wideverbatim}
NIL:  /
      |
      V
+-----+-----+-----+-----+
|  /  |  /  |  /  |  /  |
+-----+--+--+-----+-----+
\end{wideverbatim}

The reason for that structure is \texttt{NIL}'s dual nature both as a symbol
and as a list:

\begin{itemize}
\item As a symbol, it should give \texttt{NIL} for its VAL, and be without
   properties
\item For the empty list, \texttt{NIL} should give \texttt{NIL} both for its CAR and for
   its CDR
\end{itemize}

These requirements are fulfilled by the above structure.

 

\paragraph{Internal Symbols}
\label{sec:refm-internal-symbols}%
Internal Symbols are all those ``normal'' symbols, as they are used for
function definitions and variable names. They are ``interned'' into an
index structure, so that it is possible to find an internal symbol by
searching for its name.

There cannot be two different internal symbols with the same name.

Initially, a new internal symbol's VAL is \texttt{NIL}.



\paragraph{Transient Symbols}
\label{sec:refm-transient-symbols}%
Transient symbols are only interned into a index structure for a certain
time (e.g. while reading the current source file), and are released
after that. That means, a transient symbol cannot be accessed then by
its name, and there may be several transient symbols in the system
having the same name.

Transient symbols are used

\begin{itemize}
\item as text strings
\item as identifiers with a limited access scope (like, for example,
   \texttt{static} identifiers in the C language family)
\item as anonymous, dynamically created objects (without a name)
\end{itemize}

Initially, a new transient symbol's VAL is that symbol itself.

A transient symbol without a name can be created with the \texttt{box} or \texttt{new}
functions.

 

\paragraph{External Symbols}
\label{sec:refm-external-symbols}%
External symbols reside in a database file (or a similar resources, see
\texttt{*Ext}), and are loaded into memory - and written back to the file -
dynamically as needed, and transparently to the programmer. They are
kept in memory (``cached'') as long as they are accessible (``referred to'')
from other parts of the program, or when they were modified but not yet
written to the database file (by \texttt{commit}).

The interpreter recognizes external symbols internally by an additional
tag bit in the tail structure.

There cannot be two different external symbols with the same name.
External symbols are maintained in index structures while they are
loaded into memory, and have their external location (disk file and
block offset) directly coded into their names (more details
\emph{here}).

Initially, a new external symbol's VAL is \texttt{NIL}, unless otherwise
specified at creation time.

 
\subsubsection{Lists}
\label{sec:refm-lists}%
A list is a sequence of one or more cells, holding numbers, symbols, or
lists.


\begin{wideverbatim}
|
V
+-----+-----+
| any |  |  |
+-----+--+--+
         |
         V
         +-----+-----+
         | any |  |  |
         +-----+--+--+
                  |
                  V
                  ...
\end{wideverbatim}

Lists are used in PicoLisp to emulate composite data structures like
arrays, trees, stacks or queues.

In contrast to lists, numbers and symbols are collectively called
``Atoms''.

Typically, the CDR of each cell in a list points to the following cell,
except for the last cell which points to \texttt{NIL}. If, however, the CDR of
the last cell points to an atom, that cell is called a ``dotted pair''
(because of its I/O syntax with a dot `\texttt{.}' between the two values).

\subsection{Memory Management}
\label{sec:refm-memory-management}


The PicoLisp interpreter has complete knowledge of all data in the
system, due to the type information associated with every pointer.
Therefore, an efficient garbage collector mechanism can easily be
implemented. PicoLisp employs a simple but fast mark-and-sweep garbage
collector.

As the collection process is very fast (in the order of milliseconds per
megabyte), it was not necessary to develop more complicated,
time-consuming and error-prone garbage collection algorithms (e.g.
incremental collection). A compacting garbage collector is also not
necessary, because the single cell data type cannot cause heap
fragmentation.

 
\section{Programming Environment}
\label{sec:refm-programming-environment}


Lisp was chosen as the programming language, because of its clear and
simple structure.

In some previous versions, a Forth-like syntax was also implemented on
top of a similar virtual machine (Lifo). Though that language was more
flexible and expressive, the traditional Lisp syntax proved easier to
handle, and the virtual machine can be kept considerably simpler.
PicoLisp inherits the major advantages of classical Lisp systems like

\begin{itemize}
\item Dynamic data types and structures
\item Formal equivalence of code and data
\item Functional programming style
\item An interactive environment
\end{itemize}

In the following, some concepts and peculiarities of the PicoLisp
language and environment are described.

 

 
\subsection{Installation}
\label{sec:refm-installation}


PicoLisp supports two installation strategies: Local and Global.

Normally, if you didn't build PicoLisp yourself but installed it with
your operating system's package manager, you will have a global
installation. This allows system-wide access to the executable and
library/documentation files.

To get a local installation, you can directly download the PicoLisp
tarball, and follow the instructions in the INSTALL file.

A local installation will not interfere in any way with the world
outside its directory. There is no need to touch any system locations,
and you don't have to be root to install it. Many different versions -
or local modifications - of PicoLisp can co-exist on a single machine.

Note that you are still free to have local installations along with a
global installation, and invoke them explicitly as desired.

Most examples in the following apply to a global installation.

 

 
\subsection{Invocation}
\label{sec:refm-invocation}


When PicoLisp is invoked from the command line, an arbitrary number of
arguments may follow the command name.

By default, each argument is the name of a file to be executed by the
interpreter. If, however, the argument's first character is a hyphen
`\texttt{-}', then the rest of that argument is taken as a Lisp function call
(without the surrounding parentheses), and a hyphen by itself as an
argument stops evaluation of the rest of the command line (it may be
processed later using the \texttt{argv} and \texttt{opt} functions). This whole
mechanism corresponds to calling \texttt{(load T)}.

A special case is if the last argument is a single `\texttt{+}'. This will
switch on debug mode (the \texttt{*Dbg} global variable) and discard the `\texttt{+}'.

As a convention, PicoLisp source files have the extension ` \texttt{.l} '.

Note that the PicoLisp executable itself does not expect or accept any
command line flags or options (except the `\texttt{+}', see above). They are
reserved for application programs.

The simplest and shortest invocation of PicoLisp does nothing, and exits
immediately by calling \texttt{bye}:


\begin{wideverbatim}
$ picolisp -bye
$
\end{wideverbatim}

In interactive mode, the PicoLisp interpreter (see \texttt{load}) will also
exit when \texttt{Ctrl-D} is entered:


\begin{wideverbatim}
$ picolisp
: $                     # Typed Ctrl-D
\end{wideverbatim}

To start up the standard PicoLisp environment, several files should be
loaded. The most commonly used things are in ``lib.l'' and in a bunch of
other files, which are in turn loaded by ``ext.l''. Thus, a typical call
would be:


\begin{wideverbatim}
$ picolisp lib.l ext.l
\end{wideverbatim}

The recommended way, however, is to call the ``pil'' shell script, which
includes ``lib.l'' and ``ext.l''. Given that your current project is loaded
by some file ``myProject.l'' and your startup function is \texttt{main}, your
invocation would look like:


\begin{wideverbatim}
$ pil myProject.l -main
\end{wideverbatim}

For interactive development it is recommended to enable debugging mode,
to get the vi-style command line editor, single-stepping, tracing and
other debugging utilities.


\begin{wideverbatim}
$ pil myProject.l -main +
\end{wideverbatim}

This is - in a local installation - equivalent to


\begin{wideverbatim}
$ ./dbg myProject.l -main
\end{wideverbatim}

or


\begin{wideverbatim}
$ ./pil myProject.l -main +
\end{wideverbatim}

In any case, the directory part of the first file name supplied
(normally, the path to ``lib.l'' as called by `pil' or `dbg') is
remembered internally as the \emph{PicoLisp Home Directory}. This path is
later automatically substituted for any leading ` \texttt{@} ' character in file
name arguments to I/O functions (see \texttt{path}).

 

 
\subsection{Input/Output}
\label{sec:refm-input/output}


In Lisp, each internal data structure has a well-defined external
representation in human-readable format. All kinds of data can be
written to a file, and restored later to their original form by reading
that file.

In normal operation, the PicoLisp interpreter continuously executes an
infinite ``read-eval-print loop''. It reads one expression at a time,
evaluates it, and prints the result to the console. Any input into the
system, like data structures and function definitions, is done in a
consistent way no matter whether it is entered at the console or read
from a file.

Comments can be embedded in the input stream with the hash \texttt{\#}
character. Everything up to the end of that line will be ignored by the
reader.


\begin{wideverbatim}
: (* 1 2 3)  # This is a comment
-> 6
\end{wideverbatim}

A comment spanning several lines may be enclosed between \texttt{\#\{} and \texttt{\}\#}.

Here is the I/O syntax for the individual PicoLisp data types (numbers,
symbols and lists) and for read-macros:

 

\subsubsection{Numbers}
\label{sec:refm-numbers}%
A number consists of an arbitrary number of digits (`\texttt{0}' through
`\texttt{9}'), optionally preceded by a sign character (`\texttt{+}' or `\texttt{-}'). Legal
number input is:


\begin{wideverbatim}
: 7
-> 7
: -12345678901245678901234567890
-> -12345678901245678901234567890
\end{wideverbatim}

Fixpoint numbers can be input by embedding a decimal point `\texttt{.}', and
setting the global variable \texttt{*Scl} appropriately:


\begin{wideverbatim}
: *Scl
-> 0

: 123.45
-> 123
: 456.78
-> 457

: (setq *Scl 3)
-> 3
: 123.45
-> 123450
: 456.78
-> 456780
\end{wideverbatim}

Thus, fixpoint input simply scales the number to an integer value
corresponding to the number of digits in \texttt{*Scl}.

Formatted output of scaled fixpoint values can be done with the \texttt{format}
and \texttt{round} functions:


\begin{wideverbatim}
: (format 1234567890 2)
-> "12345678.90"
: (format 1234567890 2 "." ",")
-> "12,345,678.90"
\end{wideverbatim}


\subsubsection{Symbols}
\label{sec:refm-symbols}%
The reader is able to recognize the individual symbol types from their
syntactic form. A symbol name should - of course - not look like a legal
number (see above).

In general, symbol names are case-sensitive. \texttt{car} is not the same as
CAR.

 
\paragraph{NIL}
\label{sec:refm-nil}%
Besides for standard normal form, \texttt{NIL} is also recognized as
\texttt{()}, \texttt{[]} or \texttt{""}.


\begin{wideverbatim}
: NIL
-> NIL
: ()
-> NIL
: ""
-> NIL
\end{wideverbatim}

Output will always appear as \texttt{NIL}.



\paragraph{Internal Symbols}
\label{sec:refm-internal-symbols}%
Internal symbol names can consist of any printable (non-whitespace)
character, except for the following meta characters:


\begin{wideverbatim}
"  '  (  )  ,  [  ]  `  ~ { }
\end{wideverbatim}

It is possible, though, to include these special characters into symbol
names by escaping them with a backslash `\textbackslash'.

The dot `\texttt{.}' has a dual nature. It is a meta character when standing
alone, denoting a \emph{dotted pair}, but can otherwise be used in
symbol names.

As a rule, anything not recognized by the reader as another data type
will be returned as an internal symbol.



\paragraph{Transient Symbols}
\label{sec:refm-transient-symbols}%
A transient symbol is anything surrounded by double quotes `\texttt{""}'. With
that, it looks - and can be used - like a string constant in other
languages. However, it is a real symbol, and may be assigned a value or
a function definition, and properties.

Initially, a transient symbol's value is that symbol itself, so that it
does not need to be quoted for evaluation:


\begin{wideverbatim}
: "This is a string"
-> "This is a string"
\end{wideverbatim}

However, care must be taken when assigning a value to a transient
symbol. This may cause unexpected behavior:


\begin{wideverbatim}
: (setq "This is a string" 12345)
-> 12345
: "This is a string"
-> 12345
\end{wideverbatim}

The name of a transient symbol can contain any character except the
null-byte. A double quote character can be escaped with a backslash
`\textbackslash', and a backslash itself has to be escaped with another backslash.
Control characters can be written with a preceding hat `\texttt{\^}' character.

\begin{wideverbatim}
: "We^Ird\\Str\"ing"
-> "We^Ird\\Str\"ing"
: (chop @)
-> ("W" "e" "^I" "r" "d" "\\" "S" "t" "r" "\"" "i" "n" "g")
\end{wideverbatim}

The index for transient symbols is cleared automatically before and
after  \texttt{load}ing a source file, or it can be reset explicitly with the \texttt{====} function. With that mechanism, it is possible to create symbolsb
with a local access scope, not accessible from other parts of the
program.

A special case of transient symbols are \emph{anonymous symbols}. These are
symbols without name (see \texttt{box}, \texttt{box?} or \texttt{new}). They print as a
dollar sign (\texttt{\$}) followed by a decimal digit string (actually their
machine address).


\paragraph{External Symbols}
\label{sec:refm-external-symbols}%
External symbol names are surrounded by braces (`\texttt{{}' and `\texttt{}}'). The
characters of the symbol's name itself identify the physical location of
the external object. This is

\begin{itemize}
\item in the 32-bit version: The number of the database file, and -
   separated by a hyphen - the starting block in the database file. Both
   numbers are encoded in base--64 notation (characters `\texttt{0}' through
   `\texttt{9}', `\texttt{:}', `\texttt{;}', `\texttt{A}' through `\texttt{Z}' and `\texttt{a}' through `\texttt{z}').
\item in the 64-bit version: The number of the database file minus 1 in
   ``hax'' notation (i.e. hexadecimal/alpha notation, where  \texttt{@}  is zero,
   `\texttt{A}' is 1 and  \texttt{O}  is 15 (from ``alpha'' to ``omega'')), immediately
   followed (without a hyphen) the starting block in octal (`\texttt{0}'
   through `\texttt{7}').
\end{itemize}

In both cases, the database file (and possibly the hypen) are omitted
for the first (default) file.

 
\subsubsection{Lists}
\label{sec:refm-lists}%
Lists are surrounded by parentheses ( \texttt{(}  and  \texttt{)} ).

\texttt{(A)} is a list consisting of a single cell, with the symbol \texttt{A} in its
CAR, and \texttt{NIL} in its CDR.

\texttt{(A B C)} is a list consisting of three cells, with the symbols \texttt{A}, \texttt{B}
and \texttt{C} respectively in their CAR, and \texttt{NIL} in the last cell's CDR.

\texttt{(A . B)} is a ``dotted pair'', a list consisting of a single cell, with
the symbol \texttt{A} in its CAR, and \texttt{B} in its CDR.

PicoLisp has built-in support for reading and printing simple circular
lists. If the dot in a dotted-pair notation is immediately followed by a
closing parenthesis, it indicates that the CDR of the last cell points
back to the beginning of that list.


\begin{wideverbatim}
: (let L '(a b c) (conc L L))
-> (a b c .)
: (cdr '(a b c .))
-> (b c a .)
: (cddddr '(a b c .))
-> (b c a .)
\end{wideverbatim}

A similar result can be achieved with the function \texttt{circ}. Such lists
must be used with care, because many functions won't terminate or will
crash when given such a list.

\subsubsection{Read-Macros}
\label{sec:refm-read-macros}%
Read-macros in PicoLisp are special forms that are recognized by the
reader, and modify its behavior. Note that they take effect immediately
while  \texttt{read}ing an expression, and are not seen by the \texttt{eval} in the
main loop.

The most prominent read-macro in Lisp is the single quote character \texttt{'} 
which expands to a call of the \texttt{quote} function. Note that the single
quote character is also printed instead of the full function name.


\begin{wideverbatim}
: '(a b c)
-> (a b c)
: '(quote . a)
-> 'a
: (cons 'quote 'a)   # (quote . a)
-> 'a
: (list 'quote 'a)   # (quote a)
-> '(a)
\end{wideverbatim}

A comma  \texttt{,}  will cause the reader to collect the following data item
into an \texttt{idx} tree in the global variable \texttt{*Uni}, and to return a
previously inserted equal item if present. This makes it possible to
create a unique list of references to data which do normally not follow
the rules of pointer equality. If the value of \texttt{*Uni} is \texttt{T}, the comma
read macro mechanism is disabled.

A single backquote character \texttt{`} will cause the reader to evaluate the
following expression, and return the result.


\begin{wideverbatim}
: '(a `(+ 1 2 3) z)
-> (a 6 z)
\end{wideverbatim}

A tilde character \texttt{\textasciitilde{}} inside a list will cause the reader to evaluate
the following expression, and (destructively) splice the result into the
list.


\begin{wideverbatim}
: '(a b c ~(list 'd 'e 'f) g h i)
-> (a b c d e f g h i)
\end{wideverbatim}

When a tilde character is used to separate two symbol names (without
surrounding whitespace), the first is taken as a namespace to look up
the second (64-bit version only).


\begin{wideverbatim}
: 'libA~foo  # Look up 'foo' in namespace 'libA'
-> "foo"     # "foo" is not interned in the current namespace
\end{wideverbatim}

Reading \texttt{libA\textasciitilde{}foo} is equivalent to switching the current namespace to
\texttt{libA} (with \texttt{symbols}), reading the symbol \texttt{foo}, and then switching
back to the original namespace.

Brackets (`\texttt{[}' and `\texttt{]}') can be used as super parentheses. A closing
bracket will match the innermost opening bracket, or all currently open
parentheses.


\begin{wideverbatim}
: '(a (b (c (d]
-> (a (b (c (d))))
: '(a (b [c (d]))
-> (a (b (c (d))))
\end{wideverbatim}

Finally, reading the sequence `\texttt{{}}' will result in a new anonymous
symbol with value \texttt{NIL}, equivalent to a call to \texttt{box} without
arguments.


\begin{wideverbatim}
: '({} {} {})
-> ($134599965 $134599967 $134599969)
: (mapcar val @)
-> (NIL NIL NIL)
\end{wideverbatim}

\subsection{Evaluation}
\label{sec:refm-evaluation}


PicoLisp tries to evaluate any expression encountered in the
read-eval-print loop. Basically, it does so by applying the following
three rules:

\begin{itemize}
\item A number evaluates to itself.
\item A symbol evaluates to its value (VAL).
\item A list is evaluated as a function call, with the CAR as the function
   and the CDR the arguments to that function. These arguments are in
   turn evaluated according to these three rules.
\end{itemize}


\begin{wideverbatim}
: 1234
-> 1234        # Number evaluates to itself
: *Pid
-> 22972       # Symbol evaluates to its VAL
: (+ 1 2 3)
-> 6           # List is evaluated as a function call
\end{wideverbatim}

For the third rule, however, things get a bit more involved. First - as
a special case - if the CAR of the list is a number, the whole list is
returned as it is:


\begin{wideverbatim}
: (1 2 3 4 5 6)
-> (1 2 3 4 5 6)
\end{wideverbatim}

This is not really a function call but just a convenience to avoid
having to quote simple data lists.

Otherwise, if the CAR is a symbol or a list, PicoLisp tries to obtain an
executable function from that, by either using the symbol's value, or by
evaluating the list.

What is an executable function? Or, said in another way, what can be
applied to a list of arguments, to result in a function call? A legal
function in PicoLisp is either a

\begin{description}
\item[number] When a number is used as a function, it is simply taken as a
pointer to executable code that will be called with the list of
(unevaluated) arguments as its single parameter. It is up to that code
to evaluate the arguments, or not. Some functions do not evaluate their
arguments (e.g. \texttt{quote}) or evaluate only some of their arguments (e.g.
\texttt{setq}). 
\end{description}

or a 

\begin{description}
 \item[lambda expression] A lambda expression is a list, whose CAR is
either a symbol or a list of symbols, and whose CDR is a list of
expressions. Note: In contrast to other Lisp implementations, the symbol
LAMBDA itself does not exist in PicoLisp but is implied from context.

A few examples should help to understand the practical consequences of
these rules. In the most common case, the CAR will be a symbol defined
as a function, like the \texttt{*} in:
\end{description}

\begin{wideverbatim}
: (* 1 2 3)    # Call the function '*'
-> 6
\end{wideverbatim}

Inspecting the VAL of \texttt{*} gives


\begin{wideverbatim}
: *            # Get the VAL of the symbol '*'
-> 67318096
\end{wideverbatim}

The VAL of \texttt{*} is a number. In fact, it is the numeric representation of
a C-function pointer, i.e. a pointer to executable code. This is the
case for all built-in functions of PicoLisp.

Other functions in turn are written as Lisp expressions:


\begin{wideverbatim}
: (de foo (X Y)            # Define the function 'foo'
   (* (+ X Y) (+ X Y)) )
-> foo
: (foo 2 3)                # Call the function 'foo'
-> 25
: foo                      # Get the VAL of the symbol 'foo'
-> ((X Y) (* (+ X Y) (+ X Y)))
\end{wideverbatim}

The VAL of \texttt{foo} is a list. It is the list that was assigned to \texttt{foo}
with the \texttt{de} function. It would be perfectly legal to use \texttt{setq}
instead of \texttt{de}:


\begin{wideverbatim}
: (setq foo '((X Y) (* (+ X Y) (+ X Y))))
-> ((X Y) (* (+ X Y) (+ X Y)))
: (foo 2 3)
-> 25
\end{wideverbatim}

If the VAL of \texttt{foo} were another symbol, that symbol's VAL would be used
instead to search for an executable function.

As we said above, if the CAR of the evaluated expression is not a symbol
but a list, that list is evaluated to obtain an executable function.


\begin{wideverbatim}
: ((intern (pack "c" "a" "r")) (1 2 3))
-> 1
\end{wideverbatim}

Here, the \texttt{intern} function returns the symbol \texttt{car} whose VAL is used
then. It is also legal, though quite dangerous, to use the code-pointer
directly:


\begin{wideverbatim}
: *
-> 67318096
: ((* 2 33659048) 1 2 3)
-> 6
: ((quote . 67318096) 1 2 3)
-> 6
: ((quote . 1234) (1 2 3))
Segmentation fault
\end{wideverbatim}

When an executable function is defined in Lisp itself, we call it a
\emph{lambda expression}. A lambda expression always has a list of executable
expressions as its CDR. The CAR, however, must be a either a list of
symbols, or a single symbol, and it controls the evaluation of the
arguments to the executable function according to the following rules:


\begin{description}
\item[When the CAR is a list of symbols] For each of these symbols an
  argument is evaluated, then the symbols are bound simultaneously to
  the results. The body of the lambda expression is executed, then the
  VAL's of the symbols are restored to their original values. This is
  the most common case, a fixed number of arguments is passed to the
  function.
\item[Otherwise, when the CAR is the symbol \texttt{@}] All arguments
  are evaluated and the results kept internally in a list. The body of
  the lambda expression is executed, and the evaluated arguments can
  be accessed sequentially with the \texttt{args}, \texttt{next},
  \texttt{arg} and \texttt{rest} functions. This allows to define
  functions with a variable number of evaluated arguments.
\item[Otherwise, when the CAR is a single symbol] The symbol is bound
  to the whole unevaluated argument list. The body of the lambda
  expression is executed, then the symbol is restored to its original
  value. This allows to define functions with unevaluated arguments.
  Any kind of interpretation and evaluation of the argument list can
  be done inside the expression body.
\end{description}

In all cases, the return value is the result of the last expression in
the body.

\begin{wideverbatim}
: (de foo (X Y Z)                   # CAR is a list of symbols
   (list X Y Z) )                   # Return a list of all arguments
-> foo
: (foo (+ 1 2) (+ 3 4) (+ 5 6))
-> (3 7 11)                         # all arguments are evaluated
\end{wideverbatim}


\begin{wideverbatim}
: (de foo X                         # CAR is a single symbol
   X )                              # Return the argument
-> foo
: (foo (+ 1 2) (+ 3 4) (+ 5 6))
-> ((+ 1 2) (+ 3 4) (+ 5 6))        # the whole unevaluated list is returned
\end{wideverbatim}


\begin{wideverbatim}
: (de foo @                         # CAR is the symbol '@'
   (list (next) (next) (next)) )    # Return the first three arguments
-> foo
: (foo (+ 1 2) (+ 3 4) (+ 5 6))
-> (3 7 11)                         # all arguments are evaluated
\end{wideverbatim}

Note that these forms can also be combined. For example, to evaluate
only the first two arguments, bind the results to \texttt{X} and \texttt{Y}, and bind
all other arguments (unevaluated) to \texttt{Z}:


\begin{wideverbatim}
: (de foo (X Y . Z)                 # CAR is a list with a dotted-pair tail
   (list X Y Z) )                   # Return a list of all arguments
-> foo
: (foo (+ 1 2) (+ 3 4) (+ 5 6))
-> (3 7 ((+ 5 6)))                  # Only the first two arguments are evaluated
\end{wideverbatim}

Or, a single argument followed by a variable number of arguments:


\begin{wideverbatim}
: (de foo (X . @)                   # CAR is a dotted-pair with '@'
   (println X)                      # print the first evaluated argument
   (while (args)                    # while there are more arguments
      (println (next)) ) )          # print the next one
-> foo
: (foo (+ 1 2) (+ 3 4) (+ 5 6))
3                                   # X
7                                   # next argument
11                                  # and the last argument
-> 11
\end{wideverbatim}

In general, if more than the expected number of arguments is supplied to
a function, these extra arguments will be ignored. Missing arguments
default to \texttt{NIL}.

 

 
\subsection{Coroutines}
\label{sec:refm-coroutines}


Coroutines are independent execution contexts. They may have multiple
entry and exit points, and preserve their environment between
invocations.

They are available only in the 64-bit version.

A coroutine is identified by a tag. This tag can be passed to other
functions, and (re)invoked as needed. In this regard coroutines are
similar to ``continuations'' in other languages.

When the tag goes out of scope while it is not actively running, the
coroutine will be garabage collected. In cases where this is desired,
using a \emph{transient} symbol for the tag is recommended.

A coroutine is created by calling \texttt{co}. Its \texttt{prg} body will be executed,
and unless \texttt{yield} is called at some point, the coroutine will ``fall
off'' at the end and disappear.

When \texttt{yield} is called, control is either transferred back to the
caller, or to some other - explicitly specified, and already running -
coroutine.

A coroutine is stopped and disposed when

\begin{itemize}
\item execution falls off the end
\item some other (co)routine calls \texttt{co} with that tag but without a \texttt{prg}
   body
\item a \texttt{throw} into another (co)routine environment is executed
\item an error occurred, and \emph{error handling} was entered
\end{itemize}

In the current implementation, not more than 64 coroutines can exist at
the same time. Reentrant coroutines are not supported, a coroutine
cannot resume itself directly or indirectly.

 

 
\subsection{Interrupt}
\label{sec:refm-interrupt}


During the evaluation of an expression, the PicoLisp interpreter can be
interrupted at any time by hitting \texttt{Ctrl-C}. It will then enter the
breakpoint routine, as if \texttt{!} were called.

Hitting ENTER at that point will continue evaluation, while \texttt{(quit)}
will abort evaluation and return the interpreter to the top level. See
also \texttt{debug}, \texttt{e}, \texttt{\textasciicircum{}} and \texttt{*Dbg}

Other interrupts may be handled by \texttt{alarm}, \texttt{sigio}, \texttt{*Hup} and
\texttt{*Sig[12]}.

 

 
\subsection{Error Handling}
\label{sec:refm-error-handling}


When a runtime error occurs, execution is stopped and an error handler
is entered.

The error handler resets the I/O channels to the console, and displays
the location (if possible) and the reason of the error, followed by an
error message. That message is also stored in the global \texttt{*Msg}, and the
location of the error in \texttt{\textasciicircum{}}. If the VAL of the global \texttt{*Err} is
non-\texttt{NIL} it is executed as a \texttt{prg} body. If the standard input is from
a terminal, a read-eval-print loop (with a question mark ` \texttt{?} ' as
prompt) is entered (the loop is exited when an empty line is input).
Then all pending \texttt{finally} expressions are executed, all variable
bindings restored, and all files closed. If the standard input is not
from a terminal, the interpreter terminates. Otherwise it is reset to
its top-level state.


\begin{wideverbatim}
: (de foo (A B) (badFoo A B))       # 'foo' calls an undefined symbol
-> foo
: (foo 3 4)                         # Call 'foo'
!? (badFoo A B)                     # Error handler entered
badFoo -- Undefined
? A                                 # Inspect 'A'
-> 3
? B                                 # Inspect 'B'
-> 4
?                                   # Empty line: Exit
:
\end{wideverbatim}

Errors can be caught with \texttt{catch}, if a list of substrings of possible
error messages is supplied for the first argument. In such a case, the
matching substring (or the whole error message if the substring is
\texttt{NIL}) is returned.

An arbitrary error can be thrown explicitly with \texttt{quit}.

 

 
\subsection{@ Result}
\label{sec:refm-@-result}


In certain situations, the result of the last evaluation is stored in
the VAL of the symbol \texttt{@}. This can be very convenient, because it often
makes the assignment to temporary variables unnecessary.

This happens in two - only superficially similar - situations:

\begin{description}
\item[load] In read-eval loops, the last three results which were
  printed at the console are available in \texttt{@@@}, \texttt{@@}
  and~\texttt{@}, in that order (i.e the latest result is
  in~\texttt{@}).

\begin{wideverbatim}
: (+ 1 2 3)
-> 6
: (/ 128 4)
-> 32
: (- @ @@)        # Subtract the last two results
-> 26
\end{wideverbatim}

\item[Flow functions] Flow- and logic-functions store the result of
  their controlling expression - respectively non-\texttt{NIL} results
  of their conditional expression - in~\texttt{@}.

\begin{wideverbatim}
: (while (read) (println 'got: @))
abc            # User input
got: abc       # print result
123            # User input
got: 123       # print result
NIL
-> 123

: (setq L (1 2 3 4 5 1 2 3 4 5))
-> (1 2 3 4 5 1 2 3 4 5)
: (and (member 3 L) (member 3 (cdr @)) (set @ 999))
-> 999
: L
-> (1 2 3 4 5 1 2 999 4 5)
\end{wideverbatim}

Functions with controlling expressions are \emph{case},
\emph{prog1}, \emph{prog2}, and the bodies
of \texttt{*Run} tasks.

Functions with conditional expressions are \emph{and},
\emph{cond}, \emph{do}, \emph{for},
\emph{if}, \emph{if2}, \emph{ifn},
\emph{loop}, \emph{nand},
\emph{nond}, \emph{nor},
\emph{not}, \emph{or},
\emph{state}, \emph{unless},
\emph{until}, \emph{when} and
\emph{while}.

\end{description}

\texttt{@} is generally local to functions and methods, its value is
automatically saved upon function entry and restored at exit.

\subsection{Comparing}
\label{sec:refm-comparing}


In PicoLisp, it is legal to compare data items of arbitrary type. Any
two items are either

\begin{description}
\item[Identical] They are the same memory object (pointer equality).
  For example, two internal symbols with the same name are identical.
  In the 64-bit version, also short numbers (up to 60 bits plus sign)
  are pointer-equal.
\item[Equal] They are equal in every respect (structure equality), but
  need not to be identical. Examples are numbers with the same value,
  transient symbols with the same name or lists with equal elements.
\item[Or they have a well-defined ordinal relationship] Numbers are
  comparable by their numeric value, strings by their name, and lists
  recursively by their elements (if the CAR's are equal, their CDR's
  are compared). For differing types, the following rule applies:
  Numbers are less than symbols, and symbols are less than lists. As
  special cases, \texttt{NIL} is always less than anything else, and
  \texttt{T} is always greater than anything else.
\end{description}

To demonstrate this, \texttt{sort} a list of mixed data types:

\begin{wideverbatim}
: (sort '("abc" T (d e f) NIL 123 DEF))
-> (NIL 123 DEF "abc" (d e f) T)
\end{wideverbatim}

See also \texttt{max}, \texttt{min}, \texttt{rank}, \texttt{<}, \texttt{=}  \texttt{>} etc.

 
\subsection{OO Concepts}
\label{sec:refm-oo-concepts}

PicoLisp comes with built-in object oriented extensions. There seems to
be a common agreement upon three criteria for object orientation:

\begin{description}
\item[Encapsulation] Code and data are encapsulated into objects,
  giving them both a behavior and a state. Objects communicate by
  sending and receiving messages.
\item[Inheritance] Objects are organized into classes. The behavior of
  an object is inherited from its class(es) and superclass(es).
\item[Polymorphism] Objects of different classes may behave
  differently in response to the same message. For that, classes may
  define different methods for each message.
\end{description}

PicoLisp implements both objects and classes with symbols. Object-local
data are stored in the symbol's property list, while the code (methods)
and links to the superclasses are stored in the symbol's VAL
(encapsulation).

In fact, there is no formal difference between objects and classes
(except that objects usually are anonymous symbols containing mostly
local data, while classes are named internal symbols with an emphasis on
method definitions). At any time, a class may be assigned its own local
data (class variables), and any object can receive individual method
definitions in addition to (or overriding) those inherited from its
(super)classes.

PicoLisp supports multiple inheritance. The VAL of each object is a
(possibly empty) association list of message symbols and method bodies,
concatenated with a list of classes. When a message is sent to an
object, it is searched in the object's own method list, and then (with a
left-to-right depth-first search) in the tree of its classes and
superclasses. The first method found is executed and the search stops.
The search may be explicitly continued with the \texttt{extra} and \texttt{super}
functions.

Thus, which method is actually executed when a message is sent to an
object depends on the classes that the object is currently linked to
(polymorphism). As the method search is fully dynamic (late binding), an
object's type (i.e. its classes and method definitions) can be changed
even at runtime!

While a method body is being executed, the global variable \texttt{This} is set
to the current object, allowing the use of the short-cut property
functions \texttt{\texttt{}}, \texttt{:} and \texttt{::}.

 

 
\subsection{Database}
\label{sec:refm-database}


On the lowest level, a PicoLisp database is just a collection of
\emph{external symbols}. They reside in a database file, and are
dynamically swapped in and out of memory. Only one database can be open
at a time (\texttt{pool}).

In addition, further external symbols can be specified to originate from
arbitrary sources via the \texttt{*Ext} mechanism.

Whenever an external symbol's value or property list is accessed, it
will be automatically fetched into memory, and can then be used like any
other symbol. Modifications will be written to disk only when \texttt{commit}
is called. Alternatively, all modifications since the last call to
\texttt{commit} can be discarded by calling \texttt{rollback}.

\subsubsection{Transactions}
\label{sec:refm-transactions}%
In the typical case there will be multiple processes operating on the
same database. These processes should be all children of the same parent
process, which takes care of synchronizing read/write operations and
heap contents. Then a database transaction is normally initiated by
calling \texttt{(dbSync)}, and closed by calling \texttt{(commit 'upd)}. Short
transactions, involving only a single DB operation, are available in
functions like \texttt{new!} and methods like \texttt{put!>} (by convention with an
exclamation mark), which implicitly call \texttt{(dbSync)} and \texttt{(commit 'upd)}
themselves.

A transaction proceeds through five phases:

\begin{enumerate}
\item \texttt{dbSync} waits to get a \texttt{lock} on the root object \texttt{*DB}. Other
   processes continue reading and writing meanwhile.
\item \texttt{dbSync} calls \texttt{sync} to synchronize with changes from other
   processes. We hold the shared lock, but other processes may continue
   reading.
\item We make modifications to the internal state of external symbols with
   \texttt{put>, set>, lose>} etc. We - and also other processes - can still
   read the DB.
\item We call \texttt{(commit 'upd)}. \texttt{commit} obtains an exclusive lock (no more
   read operations by other processes), writes an optional transaction
   log, and then all modified symbols. As \texttt{upd} is passed to `commit',
   other processes synchronize with these changes.
\item Finally, all locks are released by `commit'
\end{enumerate}


 
\subsubsection{Entities / Relations}
\label{sec:refm-entities-/-relations}%
The symbols in a database can be used to store arbitrary information
structures. In typical use, some symbols represent nodes of search
trees, by holding keys, values, and links to subtrees in their VAL's.
Such a search tree in the database is called index.

For the most part, other symbols in the database are objects derived
from the \texttt{+Entity} class.

Entities depend on objects of the \texttt{+relation} class hierarchy.
Relation-objects manage the property values of entities, they define the
application database model and are responsible for the integrity of
mutual object references and index trees.

Relations are stored as properties in the entity classes, their methods
are invoked as daemons whenever property values in an entity are
changed. When defining an \texttt{+Entity} class, relations are defined - in
addition to the method definitions of a normal class - with the \texttt{rel}
function. Predefined relation classes include

\begin{itemize}
\item Primitive types like
   \texttt{+Symbol}
   Symbolic data
   \texttt{+String}
   Strings (just a general case of symbols)
   \texttt{+Number}
   Integers and fixpoint numbers
   \texttt{+Date}
   Calendar date values, represented by a number
   \texttt{+Time}
   Time-of-the-day values, represented by a number
   \texttt{+Blob}
   ``Binary large objects'' stored in separate files
\item Object-to-object relations
   \texttt{+Link}
   A reference to some other entity
   \texttt{+Hook}
   A reference to an entity holding object-local index trees
   \texttt{+Joint}
   A bi-directional reference to some other entity
\item Container prefix classes like
   \texttt{+List}
   A list of any of the other primitive or object relation types
   \texttt{+Bag}
   A list containing a mixture of any of the other types
\item Index prefix classes
   \texttt{+Ref}
   An index with other primitives or entities as key
   \texttt{+Key}
   A unique index with other primitives or entities as key
   \texttt{+Idx}
   A full-text index, typically for strings
   \texttt{+Sn}
   Tolerant index, using a modified Soundex-Algorithm
\item Booleans
   \texttt{+Bool}
   \texttt{T} or \texttt{NIL}
\item And a catch-all class
   \texttt{+Any}
   Not specified, may be any of the above relations
\end{itemize}


\subsection{Pilog (PicoLisp Prolog)}
\label{sec:refm-pilog-(picolisp-prolog)}


A declarative language is built on top of PicoLisp, that has the
semantics of Prolog, but uses the syntax of Lisp.

For an explanation of Prolog's declarative programming style, an
introduction like~\cite{prolog1} is recommended.

Facts and rules can be declared with the \texttt{be} function. For example, a
Prolog fact `\texttt{likes(john,mary).}' is written in Pilog as:


\begin{wideverbatim}
(be likes (John Mary))
\end{wideverbatim}

and a rule `\texttt{likes(john,X) :- likes(X,wine), likes(X,food).}' is in
Pilog:


\begin{wideverbatim}
(be likes (John @X) (likes @X wine) (likes @X food))
\end{wideverbatim}

As in Prolog, the difference between facts and rules is that the latter
ones have conditions, and usually contain variables.

A variable in Pilog is any symbol starting with an at-mark character
(` \texttt{@} '). The symbol \texttt{@} itself can be used as an anonymous variable: It
will match during unification, but will not be bound to the matched
values.

The \emph{cut} operator of Prolog (usually written as an exclamation mark
(\texttt{!})) is the symbol \texttt{T} in Pilog.

An interactive query can be done with the \texttt{?} function:


\begin{wideverbatim}
(? (likes John @X))
\end{wideverbatim}

This will print all solutions, waiting for user input after each line.
If a non-empty line (not just a ENTER key, but for example a dot (\texttt{.})
followed by ENTER) is typed, it will terminate.

Pilog can be called from Lisp and vice versa:

\begin{itemize}
\item The interface from Lisp is via the functions \texttt{goal} (prepare a query
   from Lisp data) and \texttt{prove} (return an association list of successful
   bindings), and the application level functions \texttt{pilog} and \texttt{solve}.
\item When the CAR of a Pilog clause is a Pilog variable, the CDR is
   executed as a Lisp expression and the result unified with that
   variable.
\item Within such a Lisp expression in a Pilog clause, the current bindings
   of Pilog variables can be accessed with the \texttt{->} function.
\end{itemize}

\subsection{Naming Conventions}
\label{sec:refm-naming-conventions}


It was necessary to introduce - and adhere to - a set of conventions for
PicoLisp symbol names. Because all (internal) symbols have a global
scope (there are no packages or name spaces), and each symbol can only
have either a value or function definition, it would otherwise be very
easy to introduce name conflicts. Besides this, source code readability
is increased when the scope of a symbol is indicated by its name.

These conventions are not hard-coded into the language, but should be so
into the head of the programmer. Here are the most commonly used ones:

\begin{itemize}
\item Global variables start with an asterisk ``\texttt{*}''
\item Functions and other global symbols start with a lower case letter
\item Locally bound symbols start with an upper case letter
\item Local functions start with an underscore `` \texttt{\_}''
\item Classes start with a plus-sign ``\texttt{+}'', where the first letter
\begin{itemize}
\item is in lower case for abstract classes
\item and in upper case for normal classes
\end{itemize}
\item Methods end with a right arrow ``\texttt{>}''
\item Class variables may be indicated by an upper case letter
\end{itemize}

For historical reasons, the global constant symbols \texttt{T} and \texttt{NIL} do not
obey these rules, and are written in upper case.

For example, a local variable could easily overshadow a function
definition:


\begin{wideverbatim}
: (de max-speed (car)
   (.. (get car 'speeds) ..) )
-> max-speed
\end{wideverbatim}

Inside the body of \texttt{max-speed} (and all other functions called during
that execution) the kernel function \texttt{car} is redefined to some other
value, and will surely crash if something like \texttt{(car Lst)} is executed.
Instead, it is safe to write:


\begin{wideverbatim}
: (de max-speed (Car)            # 'Car' with upper case first letter
   (.. (get Car 'speeds) ..) )
-> max-speed
\end{wideverbatim}

Note that there are also some strict naming rules (as opposed to the
voluntary conventions) that are required by the corresponding kernel
functionalities, like:

\begin{itemize}
\item Transient symbols are enclosed in double quotes (see
   \emph{Transient Symbols})
\item External symbols are enclosed in braces (see \emph{External Symbols})
\item Pattern-Wildcards start with an at-mark ` \texttt{@} ' (see
   \emph{match} and \emph{fill})
\item Symbols referring to a shared library contain a colon ` \texttt{lib:sym} '
\end{itemize}

With that, the last of the above conventions (local functions start with
an underscore) is not really necessary, because true local scope can be
enforced with transient symbols.

 
\subsection{Breaking Traditions}
\label{sec:refm-breaking-traditions}


PicoLisp does not try very hard to be compatible with traditional Lisp
systems. If you are used to some other Lisp dialects, you may notice the
following differences:

\begin{description}

\item[Case Sensitivity] PicoLisp distinguishes between upper case and
  lower case characters in symbol names. Thus, \texttt{CAR} and
  \texttt{car} are different symbols, which was not the case in
  traditional Lisp systems.

\item[QUOTE] In traditional Lisp, the \texttt{QUOTE} function
  returns its \emph{first} unevaluated argument. In PicoLisp, on the
  other hand, \texttt{quote} returns \emph{all} (unevaluated)
  argument(s).

\item[LAMBDA] The \texttt{LAMBDA} function, in some way at
  the heart of traditional Lisp, is completely missing (and
  \texttt{quote} is used instead).

\item[PROG] The \texttt{PROG} function of traditional Lisp,
  with its GOTO and ENTER functionality, is also missing. PicoLisp's
  \texttt{prog} function is just a simple sequencer (as \texttt{PROGN}
  in some Lisps).

\item[Function/Value] In PicoLisp, a symbol cannot have a value
  \emph{and} a function definition at the same time. Though this is a
  disadvantage at first sight, it allows a completely uniform handling
  of functional data.

\end{description} 

\subsection{Bugs}
\label{sec:refm-bugs}


The names of the symbols \texttt{T} and \texttt{NIL} violate the \emph{naming conventions}. They are global symbols, and should therefore start with
an asterisk ``\texttt{*}''. It is too easy to bind them to some other value by
mistake:


\begin{wideverbatim}
(de foo (R S T)
   ...
\end{wideverbatim}

However, \texttt{lint} will issue a warning in such a case.

\begin{thebibliography}{[9]}

\bibitem{lisp1} Winston/Horn: ``Lisp'', Addison-Wesley, 1981

\bibitem{prolog1} Clocksin/Mellish: ``Programming in Prolog'',
  Springer-Verlag, 1981

\end{thebibliography}
